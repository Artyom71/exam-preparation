Подготовка к экзамену по предмету "Алгоритмические языки" 2020.
=====================
#### 1. Двусвязный список: поиск элемента по значению, вставка элемента, удаление элемента. Реализация функции удаления элемента из двусвязного списка. Основные методы std::list. Пример работы с std::list
---
![list](https://prog-cpp.ru/wp-content/uploads/2014/04/DLS-add.png)

Оценки сложности (N - размер контейнера/количество элементов):
- Вставка/удаление - O(1)
- _Вставка/удаление нескольких элементов_ - O(M), где M - количество последовательных элементов, над которыми проивзодятся манипуляции.
- Поиск элемента - O(N)
- _Размер_ - O(1) после C++11, до этого O(N)
До C++11:
```cpp
/**  Returns the number of elements in the %list.  */ 
size_t size() const {
    return std::distance(begin(), end());
}
```
##### Основные методы:
- emplace/push_front (создает/копирует(перемещает) элемент в начало списка)
- emplace/push_back (создает/копирует(перемещает) элемент в конец списка)
- emplace/insert (создает/копирует(перемещает) элемент в указанную позицию)
- pop_back, pop_front, erase, clear (удаление с конца, с начала, удаление с известной позиции или промежутка, удаление всех элментов(size = 0))
- swap (Обменивает содержимое контейнера с контейнером x)
##### Основные операции:
- remove - удаляет элементы сравнимые с передаваемым значением (то есть по значение, а не по позиции)
- sort - сортирует элементы списка (по умолчанию в порядке возрастания)
- reverse - меняет порядок элементов в списке
- splice - переносит элементы из одного списка в другой с указанной позиции (второй список становиться пустым)
```cpp
// mylist1: 1 2 3 4
// mylist2: 10 20 30
it = mylist1.begin();
++it;       
mylist1.splice (it, mylist2);
// mylist1: 1 10 20 30 2 3 4
// mylist2 (empty)
// "it" still points to 2 (the 5th element)
```
- merge - слияние двух отсортированных списков, второй список остается пустым.

##### Реализация функции удаления:
Если элемент не является концом или началом, очищаем память и перезаписываем значение предыдущего и следующего значения. В случае конца удаляем элемент и предыдущий элемент указывает на nullptr
В случае начала удаляем первый элемент и указатель следующего указывает на nullptr
```cpp
template <typename T>
iterator list<T>::erase(iterator elem) {
  if (elem == end()) return elem;                 // Check if dereferenceble
  if (elem->prev) elem->prev->next = elem->next;  // Check if prev element exists
  else first = elem->next;                        // otherwise change list first elem
  if (elem->next) elem->next->prev = elem->prev;  // Check if next element exists
  else last = elem->prev;                         // otherwise change list last elem
  auto old = elem++;                              // Increment elem and save old iterator to delete its pointer later
  delete old.base();
  return elem;
}
```

#### 2. Класс std::map. Внутренняя реализация map, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std::map
---
![map](https://qph.fs.quoracdn.net/main-qimg-12cd34c071b5ed07220d841c3c0b2090)

Отсортированный ассоциативный контейнер, содержащий пары ключ-значение с уникальными ключами. Ключи отсортированы с помощью функции сравнения Compare. Операции поиска, удаления и вставки имеют логарифмическую сложность. Карты обычно реализованы в виде красно-черных деревьев.

Красно-черное дерево - это бинарное дерево поиска с дополнительным параметром цветом в каждом узле. В соответствии с накладываемыми на узлы дерева ограничения ни один простой путь от корня в КЧД не отличается от другого по длине более чем в два раза, таким образом КЧД являются приближенно сбалансированными.

```cpp
class map {
private:
    enum Color {
        RED, BLACK
    };

    struct Node {
        Node *Parent;
        Node *Left;
        Node *Right;
        Color color;
        _Key key;
        _T value;
    ...
```    
##### Основные методы:
- insert - вставка элемента/элементов. В последнем случае сложность O(N * log(size + N)). Поскольку ключи элемента в карте уникальны, операция вставки проверяет, есть ли у каждого вставленного элемента ключ, эквивалентный ключу элемента, уже находящегося в контейнере, и, если это так, элемент не вставляется, возвращая итератор.
```cpp
std::map<char,int> mymap;
// first insert function version (single parameter):
mymap.insert ( std::pair<char,int>('a',100) );
mymap.insert ( std::pair<char,int>('z',200) );

std::pair<std::map<char,int>::iterator,bool> ret;
ret = mymap.insert ( std::pair<char,int>('z',500) );
if (ret.second==false) {
    std::cout << "element 'z' already existed";
    std::cout << " with a value of " << ret.first->second << '\n';
}

// second insert function version (with hint position):
std::map<char,int>::iterator it = mymap.begin();
mymap.insert (it, std::pair<char,int>('b',300));  // max efficiency inserting
mymap.insert (it, std::pair<char,int>('c',400));  // no max efficiency inserting

// third insert function version (range insertion):
std::map<char,int> anothermap;
anothermap.insert(mymap.begin(),mymap.find('c'));

// showing contents:
std::cout << "mymap contains:\n";
for (it=mymap.begin(); it!=mymap.end(); ++it)
    std::cout << it->first << " => " << it->second << '\n';

std::cout << "anothermap contains:\n";
for (it=anothermap.begin(); it!=anothermap.end(); ++it)
    std::cout << it->first << " => " << it->second << '\n';
```
Вывод
```
element 'z' already existed with a value of 200
mymap contains:
a => 100
b => 300
c => 400
z => 200
anothermap contains:
a => 100
b => 300
```
- emplace - Вставляет новый элемент в карту, если его ключ уникален. Этот новый элемент создается на месте, а не копируется или перемещается.
```cpp
std::map<char, int> mymap;
mymap.emplace('a', 1);
mymap.emplace('b', 2);
```
- erase - удаление элемента по ключу, по итератору или в диапозоне.
```cpp
std::map<char, int> mymap;
mymap['a'] = 1;
mymap['b'] = 2;
mymap.erase('a');
```
- swap - обменивает содержимое контейнера на содержимое x , который является другой картой того же типа. Размеры могут отличаться.
- clear - удаление всех элементов из карты.
- find - ищет в контейнере элемент с указанным ключем, возвращает итератор на найденный элемент. (Если ключа нет возвращает end())

##### Оценка сложности:
- Вставка/удаление - O(log N)
- Поиск элемента по ключу - O(log N)

#### 3. Класс std::set. Внутренняя реализация set, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std::set
---
![set](https://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Red-black_tree_example.svg/500px-Red-black_tree_example.svg.png)

std::set - множество. Элементы уникальны, а так же сравниваются и сортируются при добавлении. Чаще всего реализовано так же как и std::map с помощью красно-черных деревьев.
##### Основные методы:
- insert
- erase
- swap
- clear
- emplace
- find

###### Сложность такая же как и у std::map в силу использования одинаковой структуры данных

###### Пример работы:
```cpp
std::set<int> myset;
std::set<int>::iterator it;
std::pair<std::set<int>::iterator,bool> ret;

// set some initial values:
for (int i=1; i<=5; ++i) myset.insert(i*10);    // set: 10 20 30 40 50

ret = myset.insert(20);               // no new element inserted

if (ret.second==false) it=ret.first;  // "it" now points to element 20

myset.insert (it,25);                 // max efficiency inserting
myset.insert (it,24);                 // max efficiency inserting
myset.insert (it,26);                 // no max efficiency inserting

int myints[]= {5,10,15};              // 10 already in set, not inserted
myset.insert (myints,myints+3);       // myset: 5 10 15 20 24 25 26 30 40 50

myset.erase(10); // myset: 5 15 20 24 25 26 30 50
it = myset.begin();
it ++;

myset.erase(it); // myset: 5 20 24 25 26 30 50
it = myset.find(25);
myset.erase(it, myset.end()); // myset: 5 20 24

std::set<int> myset2 {1, 2, 3};
myset2.emplace(4);

myset1.swap(myset2)
```

#### 4. Класс std::unordered_map. Внутренняя реализация unordered_map, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std:: unordered_map
---
unordered_map - является ассоциативным контейнером, который содержит пары ключ-значение с уникальными ключами. Поиск, вставка и удаление выполняются за константное время. 
Внутренне unordered_map реализована с использованием хэш-таблицы, ключ хэшируется в индексы хэш-таблицы, поэтому производительность структуры данных во многом зависит от хэш-функции, но в среднем вставка и удаление из хэш-таблицы составляет О(1).
![hash_table](http://upload.wikimedia.org/wikipedia/commons/thumb/c/c2/HASHTB08.svg/362px-HASHTB08.svg.png)

##### Основные методы:
- emplace
- emplace_hint (hint - итератор используемый в качестве предположения о позиции, в которую нужно вставить новый элемент)
```cpp
template <class... Args>
iterator emplace_hint (const_iterator hint, Args&&... args );
```
- insert
- erase
- clear
- swap
- find

#### 5. Класс std::vector. Внутренняя реализация vector, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std::vector. Особенность std::vector<bool>.
---
std :: vector - динамический массив. Как и массивы, используются последовательные участки памяти для своих элементов, это также означает, что они могут быть использованы как в массиве по указателю, так и по распределенному указателю. Размер может изменяться автоматически, а размер автоматически обрабатывается контейнером.
    
![vector](https://qph.fs.quoracdn.net/main-qimg-d2696c877d001f9e11c316bc1c5412ac)    
##### Основные методы:
- emplace - создание и вставка элемента на заданную позицию (О(n)).
- emplace_back - создание и вставка в конец (O(1)).
- push_back - вставка элемента в конец (О(1)).
- insert - вставка элемента в указанную позицию (O(n)).
- swap - обмен содержимым с другим вектором (О(n)).
- erase - удаление элемента с указанной позиции или элементов из диапазона (O(n)).
- clear - удаление всех элементов вектора (O(n)).

- size - возвращает размер вектора (O(n)).
- resize - изменяет размер вектора (O(n)).
- capacity - возвращает количество элементов, на которые хватит зарезервированной памяти.
- reserve - резервирует области памяти для указанного количества элементов.

##### Особенности std::vector<bool>:
специализация std::vector, более эффективно использующая память путем храненения булевых значений в каждом бите (в отличие от одного значения в байте, как для переменных типа bool). Так же предоставляет особый метод - flip, для инвертирования всех значений массива.

#### 6. Парадигмы ООП. Полиморфизм (статический, динамический). Инкапсуляция. Наследование. Примеры.
---
ООП - методология программирования, в которой основными концепциями являются понятия объектов и классов. В центре ООП находится понятие объекта и данных. Парадигмы ООП: полиморфизм, наследование и инкапсуляция.

_Инкапсуляция_ - сокрытие информации, которое гарантирует что данные объекта и его методы используются по назначению. Использование инкапсуляции позволяет в дальнейшем изменять устройство классов без вреда для пользователя, при условии что открытый интерфейс объекта остается неизменным. С++ предоставляет 3 типа доступа - public, protected(доступ открыт классам, производным от данного) и private(только для функций класса или для друзей класса).

_Наследование_ - базирование одного типа данных (объекта или класса) на другом типе данных, способствующее повторному использованию уже существующего кода. Помимо повторного использования кода через наследование реализуются очевидные связи между классами, что способствует чистоте кода. С++ предлагает несколько типов наследования - public, protected, private и даже виртуальное наследование (Для разрешения проблем ромбовидного наследования), каждое из которых реализует определенное отношение между классами. К примеру public наследование реализует отношение "является".

_Полиморфизм_ - различное поведение объекта в зависимости от обстоятельств. С++ допускае два типа полиморфизма. Статический (времени компиляции) и динамический (времени исполнения)

_Статический полиморфизм_ представлен перегрузкой функций, аргументами по умолчанию и шаблонами. Таким образом функция ведет себя по разному в зависимости от параметров или типа, над которыми она работает.

_Динамический полиморфизм_ представлен наследованием и виртуальными функциями. Во время выполнения определяется какой метод необходимо использовать для соответствующего объекта в иерархии.

#### 7. Разработка обобщенных типов: шаблоны С++. Инстанцирование. Спецификация шаблонов. Примеры.
---
Шаблоны - средство C++, предназначенное для разработки обобщённых алгоритмов, без привязки к некоторым параметрам (например, типам данных). Инстанцирование шаблона – это генерация кода функции или класса по шаблону для конкретных параметров.
```cpp
template <typename T> T sqr(T);
template <typename T>
class X {
  T x;
public:
  explicit X(T x):x(x){}
  T get()const;
  void set(T);
};
```
```cpp
#include "my.h"
template <typename T>
T sqr(T x){
    return x*x;
}
template <typename T>
T X<T>::get() const {
    return x;
}
template <typename T>
void X<T>::set(T x) {
    this->x=x;
}
template double sqr(double); // явное инстанцирование шаблона функции
template int sqr(int);       // для двух типов аргументов
template class X<int>;       // и класса для типа int
```
```cpp
#include <iostream>
#include "my.h"
using namespace std;
int main()
{
  cout<<sqr(10)<<"\n";  // OK
  cout<<sqr(1.2)<<"\n"; // OK
  cout<<sqr(10L)<<"\n"; // Ошибка, нет sqr(long)
  
  X<int> x1(10); 
  cout<<x1.get()<<"\n"; // OK
  X<double> x2(1.2); 
  cout<<x2.get()<<"\n"; // Ошибка, нет X<double>::get()
  return 0;
}
```
Специализация - ручное указание реализации сущности для каких-либо конкретных параметров. Может быть полной или частичной.
```cpp
// Сама шаблонная функция. На ее месте может быть и класс
template <typename T1, typename T2>
void foo() {}

// Полная специализация
template <>
void foo<int, int>() {}

// Частичная специализация
template <typename T>
void foo<int, T>() {}
```
#### 8. Итераторы: определение, назначение, преимущества. Итераторы прямого доступа, итераторы ввода, итераторы вывода, двунаправленные итераторы, прямой итератор. Примеры.
---
Итераторы обеспечивают доступ к элементам контейнера. С помощью итераторов очень удобно перебирать элементы. Итератор описывается типом iterator. Но для каждого контейнера конкретный тип итератора будет отличаться. Так, итератор для контейнера list<int> представляет тип list<int>::iterator, а итератор контейнера vector<int> представляет тип vector<int>::iterator и так далее.
    
Для получения итераторов контейнеры в C++ обладают такими функциями, как begin() и end(). Функция begin() возвращает итератор, который указывает на первый элемент контейнера (при наличии в контейнере элементов). Функция end() возвращает итератор, который указывает на следующую позицию после последнего элемента, то есть по сути на конец контейнера. Если контейнер пуст, то итераторы, возвращаемые обоими методами begin и end совпадают. Если итератор begin не равен итератору end, то между ними есть как минимум один элемент.

С итераторами можно проводить следующие операции:
- *iter: получение элемента, на который указывает итератор
- ++iter: перемещение итератора вперед для обращения к следующему элементу
- --iter: перемещение итератора назад для обращения к предыдущему элементу. Итераторы контейнера forward_list не поддерживают операцию декремента.
- iter1 == iter2: два итератора равны, если они указывают на один и тот же элемент
- iter1 != iter2: два итератора не равны, если они указывают на разные элементы

_Итераторы ввода_ - итераторы, который перемещается только в одном направлении и поддерживает только чтение.
_Итераторы вывода_ - итераторы, допускающие запись и единичный проход в одном направлении.
_Итераторы прямого доступа_ - итератор, дополнительно к свойствам предыдущих двух, допускающий множественный проход в одном направлении.
_Двунаправленные итераторы_ - итератор, допускающий проход в обоих направлениях.
_Итератор произвольного доступа_ - итератор, допускающий произвольный доступ (арифметика указателей, доступная указателям в массивах).
![iterators](https://github.com/sergejkoll/exam-preparation/blob/master/images/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20%D0%BE%D1%82%202020-01-06%2013-25-01.png)
#### 9. Современный С++: auto, decltype, range base loop, nullptr, constexpr, enum class, if constexpr.
---
_auto_ - в С++11 auto позволяет не указывать тип переменной явно, говоря компилятору, чтобы он сам определил фактический тип переменной, на основе типа инициализируемого значения, так же  вы можете использовать auto вместо типа возвращаемого значения функции.
_decltype_ - возвращает тип заданного выражения.
```cpp
const int&& foo();
auto i = foo(); //  i будет иметь тип int
dectype(auto) i2 = foo(); //  i2 будет иметь тип const int&&
```
###### пример
```cpp
int foo();
int& foo1();
const int foo2();
const int& foo3();

int main()
{
  auto ri = foo(); // int
  auto ri1 = foo1(); // int
  auto ri2 = foo2(); // int
  auto ri3 = foo3(); // int

  auto& ri4 = foo(); // Не скомпилируется
  auto& ri5 = foo1(); // int&
  auto& ri6 = foo2(); // Не скомпилируется
  auto& ri7 = foo3(); // const int&

  auto&& ri8 = foo(); // int&&
  auto&& ri9 = foo1(); // int&
  auto&& ri10 = foo2(); // const int&&
  auto&& ri11 = foo3(); // const int&

  int k = 5;
  decltype(k)&& rk = k; // Не скомпилируется
  decltype(foo())&& ri12 = foo(); // int&&
  decltype(foo1())&& ri13 = foo1(); // int&
  
  int i = 3;
  decltype(i) ri14; // int
  decltype((i)) ri15; // int&
}
```
_Range-based for loop_ - Выполняет цикл для диапазона. Используется в качестве более удобочитаемого эквивалента традиционному циклу for, работающему в диапазоне значений, таких как все элементы в контейнере.
```cpp
std::vector<int> v =  {0, 1, 2, 3, 4, 5};
for (const int& i : v)  // доступ по константной ссылке 
    std :: cout << i << ' ';
for (auto i : v) // доступ по значению, тип i - int 
    std::cout << i << ' '; 
```
_nullptr_ - нулевое значение указателя (является константой r-value)
```cpp 
int *ptr = nullptr;
```
_constexpr_ - c помощью этого спецификатора можно создавать переменные, функции и даже объекты, которые будут рассчитаны на этапе компиляции. (Спецификатор constexpr введен для того, чтобы заставить компилятор на этапе кмпиляции создавать объекты и использовать их как константы времени компиляции.)
```cpp
constexpr int sum (int a, int b)
{
	return a + b;
}

void func()
{
	constexpr int c = sum (5, 12); // значение переменной будет посчитано на этапе компиляции
}
```
```cpp
struct A {
    constexpr static double x = 10.0;
    //const static double x = 10.0 - не скомпилируется
};

int main() {
    A a;
    return 0;
}
```
_enum class_ - перечисления с областью видимости
```cpp
enum Fruits {
    LEMON,
    KIWI
};

enum class Colors {
    PINK,
    GREY,
};

Fruits fruit = LEMON;
Colors color = Colors::PINK;
```
_if constexpr_ - if во время компиляции.
```cpp
template <typename T>
std::string str(T t) {
  if constexpr (std::is_same_v<T, std::string>) // строка или преобразуемый в строку
    return t;
  else
    return std::to_string(t);
}
```
#### 10. Современный С++: static_assert, initializer_list, default, final, override, using
---
_Стейтмент assert_ (или ещё «оператор проверочного утверждения») в C++ — это макрос препроцессора, который обрабатывает условное выражение во время выполнения. 
_static_assert_ - во время компиляции. (Поскольку static_assert не обрабатывается во время выполнения, то стейтменты static_assert могут быть размещены в любом месте кода (даже в глобальном пространстве))
```cpp
static_assert(sizeof(long) == 8, "long must be 8 bytes");
static_assert(sizeof(int) == 4, "int must be 4 bytes");
```
_initializer_list_ - список инициализации
```cpp
class ArrayInt {
///
ArrayInt(const std::initializer_list<int> &list) : ArrayInt(list.size()) // позволяем инициализацию ArrayInt через список инициализации
{
    // Инициализация нашего начального массива значениями из списка инициализации
    int count = 0;
    for (auto &element : list) {
        m_data[count] = element;
	++count;
    }
}
///
int main()
{
    ArrayInt array { 7, 6, 5, 4, 3, 2, 1 }; // список инициализации
    for (int count = 0; count < array.getLength(); ++count)
	std::cout << array[count] << ' ';

    return 0;
}
```
 _default_ - суть спецификатора заключается в том, что пользователь может указать компилятору реализовать ту или иную функцию-член класса по-умолчанию.(применим только к конструкторам, деструктору и оператору присваивания/перемещения)
```cpp
class Foo
{
public:
    Foo() {} // Foo() = default;
    Foo(int x) {/* ... */}
};
```
_final_ - С++11 позволяет запрещать в классах-наследниках переопределение определенных методов. Достигается это за счет применения спецификатора final рядом с сигнатурой метода.
```cpp
class Base
{
public:
    virtual void doSomething(int x) final;
};
// ...
class Derived : public Base
{
public:
    virtual void doSomething(int x); // ошибка!
};
```
_override_ - компилятор, обнаружив override, проверяет существование метода с данной сигнатурой в базовом классе. Если же такого метода нет — выдает ошибку.
```cpp
class Base
{
public:
    virtual void doSomething(int x);
};
// ...
class Derived : public Base
{
public:
    virtual void doSomething(long x) override;
};
```
_using_ - используется для создания псевдонимов типа данных.
```cpp
using iterator = typename std::vector<value_type>::iterator;
```
#### 11. Современный С++: std::optional, std::variant, std::any, std::string_view. Примеры использования
---
```std::optional``` — новый вспомогательный тип, добавленный в C++17. Это обёртка для вашего типа и флаг показывает, инициализировано ваше значение или нет. (является обёрткой для того, чтобы выразить nullable тип, не использует динамическое выделение памяти, еявно приводится к bool, таким образом вы можете легко проверить, содержится ли в нём какое-либо значение, или нет)

```std::variant<int, ...> v``` - в языке C++ - универсальный тип, который может принимать значения разных типов данных.

```std::any``` - класс any описывает типо-безопасный контейнер для отдельных значений любого типа.
```cpp
// any type
    std::any a = 1;
    std::cout << a.type().name() << ": " << std::any_cast<int>(a) << '\n';
    a = 3.14;
    std::cout << a.type().name() << ": " << std::any_cast<double>(a) << '\n';
    a = true;
    std::cout << a.type().name() << ": " << std::any_cast<bool>(a) << '\n';
```

```std::string_view``` - это класс, не владеющий строкой, но хранящий указатель на начало строки и её размер. Таким образом мы не владеем строкой а имеем "право просмтора"
```cpp
// C++11
#include <string>
void get_vendor_from_id(const std::string& id) { // аллоцирует память, если большой массив символов передан на вход вместо std::string
    std::cout <<
        id.substr(0, id.find_last_of(':')); // аллоцирует память при создании больших подстрок
}
```
```cpp
// C++17
#include <string_view>
void get_vendor_from_id(std::string_view id) { // не аллоцирует память, работает с `const char*`, `char*`, `const std::string&` и т.д.
    std::cout <<
        id.substr(0, id.find_last_of(':')); // не аллоцирует память для подстрок
}
```

#### 12. Лямбда-функции, функторы, указатели на функции, std::functional. Примеры использования std::functional. Примеры использования лямбда-функций.

_Лямбда-выражениями_ называются безымянные локальные функции, которые можно создавать прямо внутри какого-либо выражения.(лямбда-выражения в C++ — это краткая форма записи анонимных функторов.) По умолчанию лямба-функции возвращают void, однако при наличии одного return в лямбда-выражении, компилятор вычисляет тип возвращаемого значения самостоятельно. Если же в лямбда-выражении присутствует if или switch (или другие сложные конструкции) то надо указывать возвращаемый тип самостоятельно ```[] (int _n) -> double```

_Захват переменных из внешнего контекста_ - в лямбда-функции так же можно передавать переменные (список захвата), но при попытке изменить захваченные переменные получим ошибку (так как по умолчанию генерируемый operator()() объявлен как const), чтобы это обойти используем ключевое слово mutable. Так же можно передавать параметры по ссылке и использовать "режими захвата" ```[=] - по значению, [&] - по ссылке``` тогда все переменные используемые в лямбда-функции захватываются по умолчанию.


_Функторы_ — это прежде всего классы с перегруженной операцией (), а потом любые объекты, которые умеют вести себя как функции: это указатели на функции, лямбда-функции и имена функций, но сами функции и ссылки на функции функторами не являются, потому что они в терминах С++ не объекты.

_Указатель на функцию_ -  по сути указатель на функцию содержит адрес первого байта в памяти, по которому располагается выполняемый код функции. (имя так же является указателем на функцию).

```std::functional``` - ???((((

#### 13. R-value ссылки. Семантика перемещения. std::move, std::forward. Пример.


