Подготовка к экзамену по предмету "Алгоритмические языки" 2020.
=====================
#### 1. Двусвязный список: поиск элемента по значению, вставка элемента, удаление элемента. Реализация функции удаления элемента из двусвязного списка. Основные методы std::list. Пример работы с std::list
---
![list](https://prog-cpp.ru/wp-content/uploads/2014/04/DLS-add.png)

Оценки сложности (N - размер контейнера/количество элементов):
- Вставка/удаление - O(1)
- _Вставка/удаление нескольких элементов_ - O(M), где M - количество последовательных элементов, над которыми проивзодятся манипуляции.
- Поиск элемента - O(N)
- _Размер_ - O(1) после C++11, до этого O(N)
До C++11:
```cpp
/**  Returns the number of elements in the %list.  */ 
size_t size() const {
    return std::distance(begin(), end());
}
```
##### Основные методы:
- assign (Назначает новое содержимое списка, заменяя его текущее содержимое и соответственно изменяя его размер.)
```cpp
void assign (InputIterator first, InputIterator last); // 1 (с помощью итераторов)
void assign (size_type n, const value_type& val); // 2 (кол-во, значение)
void assign (initializer_list<value_type> il); // 3 (список инициализации)
```
- emplace/push_front (создает/копирует(перемещает) элемент в начало списка)
- emplace/push_back (создает/копирует(перемещает) элемент в конец списка)
```cpp
template <class... Args>
  void emplace_front (Args&&... args);
void push_front (const value_type& val);
void push_front (value_type&& val);
```
- emplace/insert (создает/копирует(перемещает) элемент в указанную позицию)
```cpp
template <class... Args>
  iterator emplace (const_iterator position, Args&&... args);
  
iterator insert (const_iterator position, const value_type& val);
iterator insert (const_iterator position, size_type n, const value_type& val);	
iterator insert (const_iterator position, InputIterator first, InputIterator last);	
iterator insert (const_iterator position, value_type&& val);
iterator insert (const_iterator position, initializer_list<value_type> il); 
```
- pop_back, pop_front, erase, clear (удаление с конца, с начала, удаление с известной позиции или промежутка, удаление всех элментов(size = 0))
- swap (Обменивает содержимое контейнера с контейнером x)
```cpp
void swap (list& x);
first.swap(second);
```
##### Основные операции:
- remove - удаляет элементы сравнимые с передаваемым значением (то есть по значение, а не по позиции)
- sort - сортирует элементы списка (по умолчанию в порядке возрастания)
- reverse - меняет порядок элементов в списке
- splice - переносит элементы из одного списка в другой с указанной позиции (второй список становиться пустым)
```cpp
// mylist1: 1 2 3 4
// mylist2: 10 20 30
it = mylist1.begin();
++it;       
mylist1.splice (it, mylist2);
// mylist1: 1 10 20 30 2 3 4
// mylist2 (empty)
// "it" still points to 2 (the 5th element)
```
- merge - слияние двух отсортированных списков, второй список остается пустым.

##### Реализация функции удаления:
Если элемент не является концом или началом, очищаем память и перезаписываем значение предыдущего и следующего значения. В случае конца удаляем элемент и предыдущий элемент указывает на nullptr
В случае начала удаляем первый элемент и указатель следующего указывает на nullptr
```cpp
iterator erase( const_iterator pos) {
    if pos == begin() {
        pos->next->prev = nullprt;
        delete pos;
    }
    if pos == end() {
        pos->prev->next = nullptr;
        delete pos;
    }
    tmp = pos->prev;
    tmp->next = pos->next;
    pos->next->prev = tmp;
    delete pos;
}
```

#### 2. Класс std::map. Внутренняя реализация map, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std::map
---
![map](https://qph.fs.quoracdn.net/main-qimg-12cd34c071b5ed07220d841c3c0b2090)

Отсортированный ассоциативный контейнер, содержащий пары ключ-значение с уникальными ключами. Ключи отсортированы с помощью функции сравнения Compare. Операции поиска, удаления и вставки имеют логарифмическую сложность. Карты обычно реализованы в виде красно-черных деревьев.

Красно-черное дерево - это бинарное дерево поиска с дополнительным параметром цветом в каждом узле. В соответствии с накладываемыми на узлы дерева ограничения ни один простой путь от корня в КЧД не отличается от другого по длине более чем в два раза, таким образом КЧД являются приближенно сбалансированными.

```cpp
class map {
private:
    enum Color {
        RED, BLACK
    };

    struct Node {
        Node *Parent;
        Node *Left;
        Node *Right;
        Color color;
        _Key key;
        _T value;
    ...
```    
##### Основные методы:
- insert - вставка элемента/элементов. В последнем случае сложность O(N * log(size + N)). Поскольку ключи элемента в карте уникальны, операция вставки проверяет, есть ли у каждого вставленного элемента ключ, эквивалентный ключу элемента, уже находящегося в контейнере, и, если это так, элемент не вставляется, возвращая итератор.
```cpp
std::map<char,int> mymap;
// first insert function version (single parameter):
mymap.insert ( std::pair<char,int>('a',100) );
mymap.insert ( std::pair<char,int>('z',200) );

std::pair<std::map<char,int>::iterator,bool> ret;
ret = mymap.insert ( std::pair<char,int>('z',500) );
if (ret.second==false) {
    std::cout << "element 'z' already existed";
    std::cout << " with a value of " << ret.first->second << '\n';
}

// second insert function version (with hint position):
std::map<char,int>::iterator it = mymap.begin();
mymap.insert (it, std::pair<char,int>('b',300));  // max efficiency inserting
mymap.insert (it, std::pair<char,int>('c',400));  // no max efficiency inserting

// third insert function version (range insertion):
std::map<char,int> anothermap;
anothermap.insert(mymap.begin(),mymap.find('c'));

// showing contents:
std::cout << "mymap contains:\n";
for (it=mymap.begin(); it!=mymap.end(); ++it)
    std::cout << it->first << " => " << it->second << '\n';

std::cout << "anothermap contains:\n";
for (it=anothermap.begin(); it!=anothermap.end(); ++it)
    std::cout << it->first << " => " << it->second << '\n';
```
Вывод
```
element 'z' already existed with a value of 200
mymap contains:
a => 100
b => 300
c => 400
z => 200
anothermap contains:
a => 100
b => 300
```
- emplace - Вставляет новый элемент в карту, если его ключ уникален. Этот новый элемент создается на месте, а не копируется или перемещается.
```cpp
std::map<char, int> mymap;
mymap.emplace('a', 1);
mymap.emplace('b', 2);
```
- erase - удаление элемента по ключу, по итератору или в диапозоне.
```cpp
std::map<char, int> mymap;
mymap['a'] = 1;
mymap['b'] = 2;
mymap.erase('a');
```
- swap - обменивает содержимое контейнера на содержимое x , который является другой картой того же типа. Размеры могут отличаться.
- clear - удаление всех элементов из карты.
- find - ищет в контейнере элемент с указанным ключем, возвращает итератор на найденный элемент. (Если ключа нет возвращает end())

##### Оценка сложности:
- Вставка/удаление - O(log N)
- Поиск элемента по ключу - O(log N)

#### 3. Класс std::set. Внутренняя реализация set, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std::set
---
![set](https://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Red-black_tree_example.svg/500px-Red-black_tree_example.svg.png)

std::set - множество. Элементы уникальны, а так же сравниваются и сортируются при добавлении. Чаще всего реализовано так же как и std::map с помощью красно-черных деревьев.
##### Основные методы:
- insert
- erase
- swap
- clear
- emplace
- find

###### Сложность такая же как и у std::map в силу использования одинаковой структуры данных

###### Пример работы:
```cpp
std::set<int> myset;
std::set<int>::iterator it;
std::pair<std::set<int>::iterator,bool> ret;

// set some initial values:
for (int i=1; i<=5; ++i) myset.insert(i*10);    // set: 10 20 30 40 50

ret = myset.insert(20);               // no new element inserted

if (ret.second==false) it=ret.first;  // "it" now points to element 20

myset.insert (it,25);                 // max efficiency inserting
myset.insert (it,24);                 // max efficiency inserting
myset.insert (it,26);                 // no max efficiency inserting

int myints[]= {5,10,15};              // 10 already in set, not inserted
myset.insert (myints,myints+3);       // myset: 5 10 15 20 24 25 26 30 40 50

myset.erase(10); // myset: 5 15 20 24 25 26 30 50
it = myset.begin();
it ++;

myset.erase(it); // myset: 5 20 24 25 26 30 50
it = myset.find(25);
myset.erase(it, myset.end()); // myset: 5 20 24

std::set<int> myset2 {1, 2, 3};
myset2.emplace(4);

myset1.swap(myset2)
```

#### 4. Класс std::unordered_map. Внутренняя реализация unordered_map, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std:: unordered_map
---
unordered_map - является ассоциативным контейнером, который содержит пары ключ-значение с уникальными ключами. Поиск, вставка и удаление выполняются за константное время. 
Внутренне unordered_map реализована с использованием хэш-таблицы, ключ хэшируется в индексы хэш-таблицы, поэтому производительность структуры данных во многом зависит от хэш-функции, но в среднем вставка и удаление из хэш-таблицы составляет О(1).
![hash_table](http://upload.wikimedia.org/wikipedia/commons/thumb/c/c2/HASHTB08.svg/362px-HASHTB08.svg.png)

##### Основные методы:
- emplace
- emplace_hint (hint - итератор используемый в качестве предположения о позиции, в которую нужно вставить новый элемент)
```cpp
template <class... Args>
iterator emplace_hint (const_iterator hint, Args&&... args );
```
- insert
- erase
- clear
- swap
- find

#### 5. Класс std::vector. Внутренняя реализация vector, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std::vector. Особенность std::vector<bool>.
---
std :: vector - динамический массив. Как и массивы, используются последовательные участки памяти для своих элементов, это также означает, что они могут быть использованы как в массиве по указателю, так и по распределенному указателю. Размер может изменяться автоматически, а размер автоматически обрабатывается контейнером.
    
![vector](https://qph.fs.quoracdn.net/main-qimg-d2696c877d001f9e11c316bc1c5412ac)    
##### Основные методы:
- emplace - создание и вставка элемента на заданную позицию (О(n)).
- emplace_back - создание и вставка в конец (O(1)).
- push_back - вставка элемента в конец (О(1)).
- insert - вставка элемента в указанную позицию (O(n)).
- swap - обмен содержимым с другим вектором (О(n)).
- erase - удаление элемента с указанной позиции или элементов из диапазона (O(n)).
- clear - удаление всех элементов вектора (O(n)).

- size - возвращает размер вектора (O(n)).
- resize - изменяет размер вектора (O(n)).
- capacity - возвращает количество элементов, на которые хватит зарезервированной памяти.
- reserve - резервирует области памяти для указанного количества элементов.

##### Особенности std::vector<bool>:
специализация std::vector, более эффективно использующая память путем храненения булевых значений в каждом бите (в отличие от одного значения в байте, как для переменных типа bool). Так же предоставляет особый метод - flip, для инвертирования всех значений массива.

#### 6. Парадигмы ООП. Полиморфизм (статический, динамический). Инкапсуляция. Наследование. Примеры.
---
ООП - методология программирования, в которой основными концепциями являются понятия объектов и классов. В центре ООП находится понятие объекта и данных. Парадигмы ООП: полиморфизм, наследование и инкапсуляция.

_Инкапсуляция_ - сокрытие информации, которое гарантирует что данные объекта и его методы используются по назначению. Использование инкапсуляции позволяет в дальнейшем изменять устройство классов без вреда для пользователя, при условии что открытый интерфейс объекта остается неизменным. С++ предоставляет 3 типа доступа - public, protected(доступ открыт классам, производным от данного) и private(только для функций класса или для друзей класса).

_Наследование_ - базирование одного типа данных (объекта или класса) на другом типе данных, способствующее повторному использованию уже существующего кода. Помимо повторного использования кода через наследование реализуются очевидные связи между классами, что способствует чистоте кода. С++ предлагает несколько типов наследования - public, protected, private и даже виртуальное наследование (Для разрешения проблем ромбовидного наследования), каждое из которых реализует определенное отношение между классами. К примеру public наследование реализует отношение "является".

_Полиморфизм_ - различное поведение объекта в зависимости от обстоятельств. С++ допускае два типа полиморфизма. Статический (времени компиляции) и динамический (времени исполнения)

_Статический полиморфизм_ представлен перегрузкой функций, аргументами по умолчанию и шаблонами. Таким образом функция ведет себя по разному в зависимости от параметров или типа, над которыми она работает.

_Динамический полиморфизм_ представлен наследованием и виртуальными функциями. Во время выполнения определяется какой метод необходимо использовать для соответствующего объекта в иерархии.

#### 7. Разработка обобщенных типов: шаблоны С++. Инстанцирование. Спецификация шаблонов. Примеры.
---
Шаблоны - средство C++, предназначенное для разработки обобщённых алгоритмов, без привязки к некоторым параметрам (например, типам данных). Инстанцирование шаблона – это генерация кода функции или класса по шаблону для конкретных параметров.
```cpp
template <typename T> T sqr(T);
template <typename T>
class X {
  T x;
public:
  explicit X(T x):x(x){}
  T get()const;
  void set(T);
};
```
```cpp
#include "my.h"
template <typename T>
T sqr(T x){
    return x*x;
}
template <typename T>
T X<T>::get() const {
    return x;
}
template <typename T>
void X<T>::set(T x) {
    this->x=x;
}
template double sqr(double); // явное инстанцирование шаблона функции
template int sqr(int);       // для двух типов аргументов
template class X<int>;       // и класса для типа int
```
```cpp
#include <iostream>
#include "my.h"
using namespace std;
int main()
{
  cout<<sqr(10)<<"\n";  // OK
  cout<<sqr(1.2)<<"\n"; // OK
  cout<<sqr(10L)<<"\n"; // Ошибка, нет sqr(long)
  
  X<int> x1(10); 
  cout<<x1.get()<<"\n"; // OK
  X<double> x2(1.2); 
  cout<<x2.get()<<"\n"; // Ошибка, нет X<double>::get()
  return 0;
}
```
Специализация - ручное указание реализации сущности для каких-либо конкретных параметров. Может быть полной или частичной.
```cpp
// Сама шаблонная функция. На ее месте может быть и класс
template <typename T1, typename T2>
void foo() {}

// Полная специализация
template <>
void foo<int, int>() {}

// Частичная специализация
template <typename T>
void foo<int, T>() {}
```
#### 8. Итераторы: определение, назначение, преимущества. Итераторы прямого доступа, итераторы ввода, итераторы вывода, двунаправленные итераторы, прямой итератор. Примеры.
---
Итераторы обеспечивают доступ к элементам контейнера. С помощью итераторов очень удобно перебирать элементы. Итератор описывается типом iterator. Но для каждого контейнера конкретный тип итератора будет отличаться. Так, итератор для контейнера list<int> представляет тип list<int>::iterator, а итератор контейнера vector<int> представляет тип vector<int>::iterator и так далее.
    
Для получения итераторов контейнеры в C++ обладают такими функциями, как begin() и end(). Функция begin() возвращает итератор, который указывает на первый элемент контейнера (при наличии в контейнере элементов). Функция end() возвращает итератор, который указывает на следующую позицию после последнего элемента, то есть по сути на конец контейнера. Если контейнер пуст, то итераторы, возвращаемые обоими методами begin и end совпадают. Если итератор begin не равен итератору end, то между ними есть как минимум один элемент.

С итераторами можно проводить следующие операции:
- *iter: получение элемента, на который указывает итератор
- ++iter: перемещение итератора вперед для обращения к следующему элементу
- --iter: перемещение итератора назад для обращения к предыдущему элементу. Итераторы контейнера forward_list не поддерживают операцию декремента.
- iter1 == iter2: два итератора равны, если они указывают на один и тот же элемент
- iter1 != iter2: два итератора не равны, если они указывают на разные элементы

_Итераторы ввода_ - итераторы, который перемещается только в одном направлении и поддерживает только чтение.
_Итераторы вывода_ - итераторы, допускающие запись и единичный проход в одном направлении.
_Итераторы прямого доступа_ - итератор, дополнительно к свойствам предыдущих двух, допускающий множественный проход в одном направлении.
_Двунаправленные итераторы_ - итератор, допускающий проход в обоих направлениях.
_Итератор произвольного доступа_ - итератор, допускающий произвольный доступ (арифметика указателей, доступная указателям в массивах).
